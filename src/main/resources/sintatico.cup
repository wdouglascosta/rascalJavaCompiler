import utils.*;
import tipos.*;
import core.*;
import java_cup.runtime.Symbol;
import generatedSources.sym;
import java.util.List;


parser code  {:

private NodeFactory nodeFactory = new NodeFactory();

public void report_error(String message, Object info){

    try {
        RascalSymbol s = (RascalSymbol) info;
        CompilerLogger.print(message);
        String detalhe = "Erro! Linha: " + s.getLine() + " Coluna: " + s.getColumn();
        CompilerLogger.print(detalhe);
    } catch (Exception e) {

        CompilerLogger.print("Erro inesperado");
        CompilerLogger.print(message);
    }

}

 public void report_fatal_error(String message, Object info) {
   report_error(message, info);
   throw new RuntimeException("Fatal Syntax Error");
 }

 public void syntax_error(RascalSymbol s){
    CompilerLogger.print("compiler has detected a syntax error at line " + s.getLine()
        + " column " + s.getColumn() + "\n");
}

:};

/* TERMINAL */
terminal T_PROGRAM;
terminal T_BEGIN;
terminal T_END;
terminal T_VAR;
terminal T_ABRE_PARENTESES;
terminal T_FECHA_PARENTESES;
terminal T_ATRIBUICAO;
terminal T_VIRGULA ;
terminal T_PONTO_E_VIRGULA ;
terminal T_DOIS_PONTOS ;
terminal T_PONTO;
terminal T_PROCEDURE;
terminal T_FUNCTION;
terminal T_FALSE;
terminal T_TRUE;
terminal T_IF;
terminal T_THEN;
terminal T_ELSE;
terminal T_WHILE;
terminal T_DO;
terminal T_READ;
terminal T_WRITE;
terminal T_AND;
terminal T_OR;
terminal T_NOT;
terminal T_DIV;
terminal Terminal T_MAIS;
terminal T_MENOS;
terminal T_MULTIPLICACAO;
terminal T_IGUAL;
terminal T_NAO_IGUAL;
terminal T_MAIOR_QUE;
terminal T_MENOR_QUE;
terminal T_MAIOR_IGUAL;
terminal T_MENOR_IGUAL;
terminal T_INT;
terminal T_BOOL;
terminal LexerToken T_NUM;
terminal LexerToken T_IDENT;

/* NON TERMINAL */
non terminal Bloco programa;
non terminal secao_declara_subs;
non terminal List<Comando> comando_composto;
non terminal Bloco bloco;
non terminal List<DecVar> secao_declara_vars;
non terminal List<TpDecVar> lista_declara_vars;
non terminal TpDecVar declara_vars;
non terminal List<LexerToken> lista_ident;
non terminal LexerToken tipo;
non terminal List<Comando> comandos;
non terminal Comando comando;
non terminal Comando cmdExpArit;
non terminal Comando cmdAtrib;


start with programa;

programa ::=
	T_PROGRAM T_IDENT T_PONTO_E_VIRGULA bloco:p4 T_PONTO 		{: RESULT = p4 ; CompilerLogger.print("retornou na raiz"); :}
;

bloco ::=
    secao_declara_vars:p1 secao_declara_subs:p2 comando_composto:p3 {: RESULT = nodeFactory.buildBloco(p1, null, p3);  :}
;

secao_declara_vars ::=
    |
    |T_VAR lista_declara_vars:p2    {: RESULT = nodeFactory.buildListDecVar(p2); :}
;

lista_declara_vars ::=
    |lista_declara_vars:p1 declara_vars:p2      {: RESULT = nodeFactory.buildListTpDecVar(p1, p2); :}
    |declara_vars:p1                            {: RESULT = nodeFactory.buildListTpDecVar(null, p1); :}
;

declara_vars ::=
    |lista_ident:p1 T_DOIS_PONTOS tipo:p3 T_PONTO_E_VIRGULA {: RESULT = nodeFactory.buildTpDecVar(p1, p3); :}
;

lista_ident ::=
    |lista_ident:p1 T_VIRGULA T_IDENT:p3 {: RESULT = nodeFactory.buildIdentList(p1, p3);:}
    |T_IDENT:p1 {: RESULT = nodeFactory.buildIdentList(null, p1); :}
;

tipo ::=
    T_IDENT:p1 {: RESULT = p1; :}
;

secao_declara_subs ::=

;

comando_composto ::=
    T_BEGIN comandos:p2 T_END {: RESULT = p2; :}
;

comandos ::=
    | comandos:p1 comando:p2       {: RESULT = nodeFactory.buildLstComandos(p1, p2); :}
    | comando:p1                   {: RESULT = nodeFactory.buildLstComandos(null, p1); :}
;

comando ::=
    | cmdExpArit:p1     {: RESULT = p1; :}
    | cmdAtrib:p1       {: RESULT = p1; :}
    | T_IDENT:p1        {: RESULT = p1; :}
    | T_NUM:p1          {: RESULT = p1; :}
;

cmdExpArit ::=
    comando:p1 T_MAIS comando:p3 T_PONTO_E_VIRGULA {: RESULT = nodeFactory.buildExpArit(p1, p3, Terminal.T_MAIS); :}
;

cmdAtrib ::=
    T_IDENT:p1 T_ATRIBUICAO comando:p3 T_PONTO_E_VIRGULA {: RESULT = nodeFactory.buildCmdAtrib(p1, p3); :}
;


